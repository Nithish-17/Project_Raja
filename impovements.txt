You are a senior backend engineer finalizing a Certificate Verification System
built using FastAPI, SQLAlchemy, PostgreSQL, OCR, and NLP.

Current state:
- The project contains both legacy (dummy DB, in-memory) APIs and enhanced (v2) APIs.
- The dummy database and legacy routes were used only for early testing.
- The final system must use ONLY ONE real database via SQLAlchemy.
- Uploaded certificates, extracted entities, and verification results must all be persisted.
- Verification must be meaningful and demonstrable.

Your task is to REFINE and FINALIZE the system.

────────────────────────────────────────
1. REMOVE LEGACY / DUMMY DATABASE LOGIC
────────────────────────────────────────
- Completely remove or disable:
  - dummy_db.py
  - legacy routes using in-memory storage
- Ensure NO part of the application reads or writes to a dummy or in-memory database.
- Keep only database-backed logic using SQLAlchemy and DATABASE_URL.

────────────────────────────────────────
2. SINGLE, CLEAR API FLOW
────────────────────────────────────────
Ensure the system follows ONE clear flow:

UPLOAD → OCR → ENTITY EXTRACTION → STORE IN DB → VERIFY → STORE RESULT

- Upload endpoint must:
  - Save file
  - Run OCR
  - Extract entities
  - Persist all results to the database

- Verify endpoint must:
  - Read uploaded certificate data from the database
  - Compare it against trusted/reference certificate records
  - Compute a confidence score
  - Persist verification results

────────────────────────────────────────
3. REFERENCE (TRUSTED) CERTIFICATES
────────────────────────────────────────
- Use the SAME database to store trusted/reference certificates.
- These represent issuing authority records.
- Reference certificates must NOT be created automatically from uploads.

- On application startup:
  - Check if reference certificates exist
  - If none exist, seed 2–3 demo reference certificates
  - Ensure seeding is idempotent (runs only once)

────────────────────────────────────────
4. VERIFICATION LOGIC CLARITY
────────────────────────────────────────
- Verification must compare uploaded certificates ONLY against reference certificates.
- If a strong match is found:
  - status = VERIFIED
  - confidence_score = percentage (0–100)
- If no match is found:
  - status = NOT VERIFIED
  - confidence_score = 0

- confidence_score must NEVER be undefined or null.

────────────────────────────────────────
5. DATABASE CONSISTENCY
────────────────────────────────────────
- Ensure all uploaded certificates are inserted into the database.
- Ensure extracted entities are stored.
- Ensure verification results are stored.
- Ensure tables are populated when v2 endpoints are used.

────────────────────────────────────────
6. FINAL EXPECTED BEHAVIOR
────────────────────────────────────────
- Uploading a certificate always inserts data into the DB.
- Database tables are never empty after uploads.
- Verification can return VERIFIED or NOT VERIFIED.
- Same certificate uploaded multiple times is treated as multiple submissions.
- The system is easy to explain and demo.

Do NOT:
- Reintroduce dummy databases
- Add a second database
- Auto-trust uploaded certificates
- Change API URLs unnecessarily

Generate clean, well-commented, production-quality Python code
that fits the existing project structure.
